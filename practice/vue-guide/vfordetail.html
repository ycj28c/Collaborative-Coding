<html>
    <head>
        <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    </head>
    <body>
        
		<ul id="example-1">
		  <li v-for="item in items">
		  <!--
		  你也可以用 of 替代 in 作为分隔符，因为它是最接近 JavaScript 迭代器的语法
		  <div v-for="item of items"></div>
		  -->
			{{ item.message }}
		  </li>
		  
		  <div>
		    <span v-for="n in 10">{{ n }} </span>
		  </div>
		</ul>
		
		<ul id="example-2">
		  <li v-for="(item, index) in items">
			{{ parentMessage }} - {{ index }} - {{ item.message }}
		  </li>
		  
		  <!--
		  为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有的唯一 id。这个特殊的属性相当于 Vue 1.x 的 track-by ，但它的工作方式类似于一个属性，所以你需要用 v-bind 来绑定动态值 (在这里使用简写)
		  -->
		  <div v-for="item in items" :key="item.id">
			{{ parentMessage }} - {{ item.message }}
		  </div>
		  
		  <!--类似于 v-if，你也可以利用带有 v-for 的 <template> 渲染多个元素-->
		  <ul>
			<template v-for="item in items">
			  <li>{{ item.message }}</li>
			  <li class="divider" role="presentation"></li>
			</template>
		  </ul>
		</ul>
		
		<!--你也可以用 v-for 通过一个对象的属性来迭代-->
		<ul id="v-for-object" class="demo">
		  <li v-for="value in object">
			{{ value }}
		  </li>
		  
		  <div v-for="(value, key) in object">
		    {{ key }}: {{ value }}
		  </div>
		  
		  <!--第三个参数为索引-->
		  <div v-for="(value, key, index) in object">
			{{ index }}. {{ key }}: {{ value }}
	      </div>
		  
		  <li v-for="todo in todos" v-if="!todo.isComplete">
		    {{ todo }}
		  </li>
		  <!--
		  当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。当你想为仅有的一些项渲染节点时，这种优先级的机制会十分有用，上面的代码只传递了未完成的 todos。
		  -->

		</ul>
		
        <script src="vfordetail.js"></script>
    </body>
</html>

